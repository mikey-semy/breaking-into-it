## Асинхронность: определения, работа, различия, применение.

- **Вакансии**:
  - **Циан**: Понимание принципов асинхронности.
  - **Бьюти Бот**: Опыт работы с асинхронными фреймворками (FastAPI, asyncio).
  - **7tech**: Понимание принципов асинхронного программирования.

### Определение
> Асинхронность, многопоточность, многопроцессорность - это три подхода к выполнению параллельных задач в программировании.

> Асинхронность - это способ выполнения задач, при котором выполнение одной задачи не блокирует выполнение других. Это достигается за счет использования неблокирующих операций и событийного цикла.

### Работа 
В асинхронном программированию используются конструкции, такие как async и await, которые и позволяют писать код, который выглядит синхронно, но выполняется асинхронно.

Когда программа достигает операции ввода-вывода (например, запрос к базе данных или API), она может "отпустить" управление, позволяя другим задачам выполняться в это время.

### Применение 
Асихронность особенно полезна в веб-приложениях, где необходимо обрабатывать множество запросов одновременно, не блокируя сервер.

Из моей практики простые примеры: 
- [Модуль для работы с базой данных и сессиями SQLAlchemy](https://github.com/mikey-semy/work-aedb/blob/main/app/database/session.py)

В классе контекстного менеджера `SessionContextManager` для управления сессиями базы данных имеются асинхронные магические методы входа в контекстный менеджер `__aenter__` и выхода из него `__aexit__`, методы фиксации изменений в базе данных `commit` и откатывания изменений в базе данных `rollback`. 

В `commit` и `rollback` используют await для ожидания других асинхронных операций: 
- `commit()` - ожидает, пока изменения запишутся в базу;
- `rollback()` - ожидает, пока откатяться изменения;
- `close()` - ждет пока закроется сессия.

<details>
<summary>session.py</summary>

```python
class SessionContextManager():
    """
    Контекстный менеджер для управления сессиями базы данных.
    """

    def __init__(self) -> None:
        """
        Инициализирует экземпляр SessionContextManager.
        """
        self.db_session = DatabaseSession(config)
        self.session_factory = self.db_session.create_async_session_factory()
        self.session = None

    async def __aenter__(self) -> 'SessionContextManager':
        """
        Асинхронный метод входа в контекстный менеджер.

        Returns:
            SessionContextManager: Экземпляр текущего контекстного менеджера.
        """
        self.session = self.session_factory()
        return self

    async def __aexit__(self, *args: object) -> None:
        """
        Асинхронный метод выхода из контекстного менеджера.

        Args:
            *args: Аргументы, передаваемые при выходе из контекста.
        """
        await self.rollback()

    async def commit(self) -> None:
        """
        Асинхронно фиксирует изменения в базе данных и закрывает сессию.
        """
        await self.session.commit()
        await self.session.close()
        self.session = None

    async def rollback(self) -> None:
        """
        Асинхронно откатывает изменения в базе данных и закрывает сессию.
        """
        await self.session.rollback()
        await self.session.close()
        self.session = None
```

</details>

- [Основной модуль маршрутизации для главной страницы](https://github.com/mikey-semy/work-aedb/blob/main/app/routers/v1/main.py)

Асинхронная функция `homepage` без await, так как `TemplateResponse` не выполняет никаких IO операций в момент создания - он просто создает объект ответа. А async нужен для совместимости с остальной асинхронной инфраструктурой:
- Поддержание асинхронный pipeline FastAPI;
- Возможность добавить асинхронные операции в будущем (например, обращение к БД);
- Не блокировать event loop, позволяя обрабатывать другие запросы параллельно.

<details>
<summary>main.py</summary>

```python
"""
Основной модуль маршрутизации для приложения AEDB.

Этот модуль определяет маршруты для главной страницы. 
Он использует шаблоны Jinja2 для рендеринга HTML-ответов.

Маршруты:
- /: Главная страница

Каждый маршрут возвращает HTML-ответ, используя соответствующий шаблон.
"""
from fastapi import APIRouter, Request
from fastapi.responses import HTMLResponse
from fastapi.templating import Jinja2Templates

from app.const import main_params, templates_path

templates = Jinja2Templates(directory=str(templates_path))

router = APIRouter(**main_params)

@router.get("/", response_class=HTMLResponse)
async def homepage(request: Request):
    """
    Обрабатывает запросы к главной странице.

    Args:
        request (Request): Объект запроса FastAPI.

    Returns:
        TemplateResponse: Отрендеренный HTML-ответ для главной страницы.
    """
    context = {
        "title": "AEDB",
        }
    return templates.TemplateResponse(
        request=request,
        name="index.html",
        context=context
    )
```

</details>


### Идеи для практики:
#### 1. Асинхронный модуль для скрапинга сайтов:

Разработать асинхронный [модуль для скрапинга сайтов](https://github.com/mikey-semy/apartment-serbia-telegrambot/blob/master/app/modules/WebScraper.py), который позволит эффективно извлекать данные. Это может быть полезно для получения информации о недвижимости, как в текущем проекте Apartment Serbia Telegram Bot.

В дальнейшем, на основе этого модуля, создать функционал для скрапинга ссылок [радио](https://radiopotok.ru/), который будет использоваться для создания плеера в проекте AEDB. Этот плеер можно будет интегрировать в качестве виджета на главной странице.

#### 2. Преобразование файлов Excel в формат JSON:

Реализовать функционал для преобразования файлов Excel в формат JSON, что упростит импорт данных в базу данных проекта AEDB.
Учитывая, что могут быть разные файлы с различными заголовками таблиц, необходимо предусмотреть возможность определения и обработки различных заголовков для каждого файла.

### Реализация 
#### 1. [Асинхронный модуль для скрапинга сайтов](https://github.com/mikey-semy/apartment-serbia-telegrambot/blob/master/app/modules/AsyncWebScraper.py):

1. Переписаная функция get_page:

```python
    async def aget_page(self, url) -> object:
        '''Асинхронная функция отправляет GET-запрос к URL и возвращает объект BeautifulSoup'''
        async with aiohttp.ClientSession() as session:
            async with session.get(
                url, 
                headers=Config.WebScraper.HEADERS, 
                timeout=Config.WebScraper.TIMEOUT) as response:
                html = await response.text()
                return BeautifulSoup(html, 'html.parser')
```
Заместо `requests` используется асинхронный `aiohttp`.

2. Также переписана функция задержки, предотвращающая блокировку скрейпера
```python
async def ascrape_pause(self, 
                     min_pause=Config.WebScraper.MIN_PAUSE, 
                     max_pause=Config.WebScraper.MAX_PAUSE) -> None:
        '''Асинхронная функция вводит задержку, чтобы предотвратить блокировку скрейпера'''
        delay = random.uniform(min_pause, max_pause)
        await asyncio.sleep(delay)
```
Используется `asyncio.sleep`.

3. И сама функция `ascrape_page` включает в себя await `self.ascrape_pause()`

4. Функция, которая измеряется с помощью [таймера](https://gist.github.com/mikey-semy/30d78d781d42cc5179ca5a654480f0ca)

```python
@timer
async def aget_data(self, urls: list, current_page_number: int = 1, quantity_pages: int = Config.WebScraper.QUANTITY_PAGE) -> list:
    '''Асинхронная функция get_data собирает данные со всех страниц сайта'''
       
    last_page_number = quantity_pages

    all_offers = []

    for url in urls:
        while True:

            scraper = self.__get_scraper(url, current_page_number)

            soup = await scraper.aget_page(url)

            offers_from_page = await scraper.ascrape_page(soup)

            for offer in offers_from_page:
                all_offers.append(offer)

            if not scraper.has_next_page(soup) or current_page_number == last_page_number:
                break

            current_page_number += 1

    return all_offers
```

Запрос выполняю по трем ссылкам: 

```python
url_ = [

"https://www.nekretnine.rs/apartmani/grad/beograd/kvadratura/1_500/cena/0_1000000",

"https://cityexpert.rs/izdavanje-nekretnina/beograd?ptId=1&maxPrice=550&polygonsArray=Novi%20Beograd",

"https://www.4zida.rs/prodaja-stanova/novi-sad/do-47000-evra?vece_od=25m2&manje_od=30m2&skuplje_od=45000eur"

]
```

Результаты тестов: 
| Тест | WebScraper | AsyncWebScraper |
|------|---------------------|---------------------|
| 1    | 17.51 секунды        | 1.19 секунды        |
| 2    | 16.22 секунды        | 7.15 секунды        |
| 3    | 16.39 секунды        | 9.53 секунды        |
| 4    | 16.30 секунды        | 7.15 секунды        |
| 5    | 15.72 секунды        | 7.15 секунды        |

> Да, в коде много недостатоков: отсутствие обработки ошибок, проверок наличия элементов и пустых значений, логирования и пр.

### Почитать
- [Асинхронный python без головной боли (часть 1)](https://habr.com/ru/articles/667630/)

### Немного теории по глупому вопросу:

Определение того, что должно быть асинхронным, а что может оставаться синхронным, зависит от характера выполняемых операций и их влияния на производительность и отзывчивость приложения. Вот несколько ключевых факторов, которые помогут вам принять решение:

#### 1. Тип операции

Сетевые запросы: Если ваша программа выполняет HTTP-запросы (например, к API или веб-сайтам), эти операции обычно занимают время из-за задержек сети. Их следует делать асинхронными, чтобы не блокировать выполнение программы, пока ожидается ответ.
Ввод-вывод (I/O): Операции, связанные с чтением и записью файлов, базами данных и другими внешними ресурсами, также могут быть асинхронными. Это позволяет программе продолжать выполнение других задач, пока ожидается завершение операции ввода-вывода.
Долгие вычисления: Если у вас есть операции, которые требуют значительных вычислительных ресурсов и могут занять много времени, их лучше выполнять в отдельных потоках или процессах, чтобы не блокировать основной поток выполнения.

#### 2. Отзывчивость приложения

Пользовательский интерфейс: Если ваше приложение имеет графический интерфейс (GUI) или работает в интерактивной среде, асинхронные операции помогут сохранить отзывчивость интерфейса. Например, если пользователь ожидает ответа от приложения, асинхронные операции позволят ему продолжать взаимодействовать с интерфейсом.

#### 3. Параллелизм и производительность

Масштабируемость: Асинхронные операции позволяют обрабатывать множество запросов одновременно, что может значительно повысить производительность приложения, особенно в веб-приложениях и сервисах.
Снижение нагрузки: Асинхронные операции могут помочь снизить нагрузку на сервер, так как они позволяют обрабатывать большее количество запросов без необходимости создания новых потоков или процессов.

#### 4. Простота кода

Сложность кода: Асинхронный код может быть сложнее для понимания и отладки. Если операция не требует асинхронности и может быть выполнена быстро, возможно, лучше оставить её синхронной для упрощения кода.
Примеры
Асинхронные операции:
Запросы к API для получения данных.
Чтение и запись файлов, когда это может занять время.
Ожидание ответов от внешних сервисов.
Синхронные операции:
Простые вычисления, которые выполняются быстро.
Логика, которая не зависит от внешних ресурсов и выполняется мгновенно.
Инициализация объектов и конфигурация, которые не требуют ожидания.

#### Заключение

В общем, если операция может занять время и блокировать выполнение программы, её следует сделать асинхронной. Если операция выполняется быстро и не требует ожидания, её можно оставить синхронной. Важно также учитывать контекст вашего приложения и его требования к производительности и отзывчивости.